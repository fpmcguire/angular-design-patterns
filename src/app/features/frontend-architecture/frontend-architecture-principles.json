[
  {
    "id": "unidirectional-flow",
    "name": "Unidirectional Data Flow",
    "category": "Data Flow",
    "shortDescription": "Data flows down, events flow up.",
    "description": "In Angular v21+, parent components pass data down via input() functions, while child components emit events via output() functions or store actions, making the flow easy to reason about and type-safe.",
    "exampleTs": [
      "import { Component, input, output } from '@angular/core';",
      "",
      "@Component({",
      "  selector: 'app-todo-list',",
      "  template: `",
      "    <ul>",
      "      @for (todo of todos(); track todo) {",
      "        <li>",
      "          <span>{{ todo }}</span>",
      "          <button (click)=\"remove.emit(todo)\">x</button>",
      "        </li>",
      "      }",
      "    </ul>",
      "  `",
      "})",
      "export class TodoListComponent {",
      "  todos = input<string[]>([]);",
      "  remove = output<string>();",
      "}"
    ]
  },
  {
    "id": "single-source-of-truth",
    "name": "Single Source of Truth",
    "category": "State Management",
    "shortDescription": "Each piece of state lives in exactly one place.",
    "description": "Avoid duplicating the same state in multiple services or components; instead, centralize it using signals, stores, or facades. Derive all derived state using computed() and consume it throughout the app from this single source.",
    "exampleTs": [
      "import { Injectable } from '@angular/core';",
      "import { BehaviorSubject } from 'rxjs';",
      "",
      "// Single source of truth for auth state",
      "@Injectable({ providedIn: 'root' })",
      "export class AuthStore {",
      "  private readonly userSubject = new BehaviorSubject<string | null>(null);",
      "  readonly user$ = this.userSubject.asObservable();",
      "",
      "  setUser(user: string | null) {",
      "    this.userSubject.next(user);",
      "  }",
      "}"
    ]
  },
  {
    "id": "state-colocation",
    "name": "State Colocation",
    "category": "State Management",
    "shortDescription": "Keep state as close as possible to where it is used.",
    "description": "Use component-local state for purely local concerns, feature stores for feature-wide state, and global stores only for truly global concerns.",
    "exampleTs": [
      "import { Component, signal } from '@angular/core';",
      "",
      "@Component({",
      "  selector: 'app-tabs',",
      "  template: `",
      "    <button (click)=\"active.set('overview')\">Overview</button>",
      "    <button (click)=\"active.set('details')\">Details</button>",
      "",
      "    @if (active() === 'overview') {",
      "      <section>Overview content</section>",
      "    }",
      "    @if (active() === 'details') {",
      "      <section>Details content</section>",
      "    }",
      "  `",
      "})",
      "export class TabsComponent {",
      "  // colocated UI state, no need for a global service/store",
      "  active = signal<'overview' | 'details'>('overview');",
      "}"
    ]
  },
  {
    "id": "smart-dumb",
    "name": "Separation of Concerns (Smart vs. Dumb Components)",
    "category": "Boundaries",
    "shortDescription": "Containers fetch and orchestrate; presentational components focus on UI.",
    "description": "Smart components own data loading, orchestration, and navigation, while dumb components receive data and emit events, staying purely presentational.",
    "exampleTs": [
      "import { Component, signal } from '@angular/core';",
      "",
      "@Component({",
      "  selector: 'app-users-container',",
      "  template: `",
      "    <app-user-list",
      "      [users]=\"users()\"",
      "      (selectUser)=\"onSelect($event)\">",
      "    </app-user-list>",
      "  `",
      "})",
      "export class UsersContainerComponent {",
      "  users = signal(['Ana', 'Bruno']);",
      "",
      "  onSelect(user: string) {",
      "    console.log('Selected', user);",
      "  }",
      "}"
    ]
  },
  {
    "id": "explicit-boundaries",
    "name": "Explicit Feature Boundaries",
    "category": "Boundaries",
    "shortDescription": "Group code by feature with clear public APIs.",
    "description": "Organize Angular apps into feature folders/libraries (auth, orders, dashboard) and expose only facades/public services, keeping internals private.",
    "exampleTs": [
      "// Example: 'orders' feature exports only OrdersFacade as public API",
      "export * from './lib/orders-facade.service';",
      "// internal services/components stay internal to the feature library."
    ]
  }
]
