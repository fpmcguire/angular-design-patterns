[
  {
    "id": "container-presenter",
    "name": "Container–Presenter Components",
    "category": "Component & UI",
    "shortDescription": "Split smart (data) and dumb (view-only) components.",
    "description": "A container component handles state, services, and data fetching (via signals, services, etc.), while a presenter component receives data via input() function and emits user events via output() function, keeping UI simple and testable.",
    "exampleTs": [
      "import { Component, signal, input, output } from \"@angular/core\";",
      "",
      "@Component({",
      "  selector: \"app-user-list-container\",",
      "  imports: [UserListComponent],",
      "  template: `",
      "    <app-user-list",
      "      [users]=\"users()\"",
      "      (selectUser)=\"onSelect($event)\">",
      "    </app-user-list>",
      "  `",
      "})",
      "export class UserListContainerComponent {",
      "  users = signal([\"Ana\", \"Bruno\", \"Carlos\"]);",
      "",
      "  onSelect(user: string) {",
      "    console.log(\"Selected\", user);",
      "  }",
      "}",

      "@Component({",
      "  selector: \"app-user-list\",",
      "  template: `",
      "    <ul>",
      "      @for (u of users(); track u) {",
      "        <li (click)=\"selectUser.emit(u)\">{{ u }}</li>",
      "      }",
      "    </ul>",
      "  `",
      "})",
      "export class UserListComponent {",
      "  users = input<string[]>([]);",
      "  selectUser = output<string>();",
      "}"
    ]
  },
  {
    "id": "compound-components",
    "name": "Compound Components via Content Projection",
    "category": "Component & UI",
    "shortDescription": "Parent component coordinates projected child UIs.",
    "description": "Expose multiple sub-areas (header, body, footer, etc.) through <ng-content> and let consumers assemble complex UIs while the parent manages behavior.",
    "exampleTs": [
      "import { Component } from \"@angular/core\";",
      "",
      "@Component({",
      "  selector: \"app-card\",",
      "  template: `",
      "    <div class=\\\"card\\\">",
      "      <div class=\\\"card-header\\\">",
      "        <ng-content select=\\\"[card-title]\\\"></ng-content>",
      "      </div>",
      "      <div class=\\\"card-body\\\">",
      "        <ng-content select=\\\"[card-body]\\\"></ng-content>",
      "      </div>",
      "      <div class=\\\"card-footer\\\">",
      "        <ng-content select=\\\"[card-footer]\\\"></ng-content>",
      "      </div>",
      "    </div>",
      "  `",
      "})",
      "export class CardComponent {}"
    ],
    "exampleHtml": [
      "<app-card>",
      "  <h2 card-title>Profile</h2>",
      "  <div card-body>Body content…</div>",
      "  <button card-footer>Save</button>",
      "</app-card>"
    ]
  },
  {
    "id": "reactive-vs-template-forms",
    "name": "Controlled vs. Uncontrolled (Reactive vs Template-Driven)",
    "category": "Component & UI",
    "shortDescription": "Compare reactive (controlled) and template-driven (less controlled) forms.",
    "description": "Reactive forms centralize form state in TypeScript and treat the UI as a projection of that state, while template-driven forms rely on template directives and implicit form models.",
    "exampleTs": [
      "import { Component, inject, signal } from \"@angular/core\";",
      "import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from \"@angular/forms\";",
      "import { FormsModule, NgForm } from \"@angular/forms\";",
      "",
      "@Component({",
      "  selector: \"app-form-demo\",",
      "  imports: [ReactiveFormsModule, FormsModule],",
      "  template: `",
      "    <!-- Reactive (controlled) -->",
      "    <form [formGroup]=\"reactiveForm()\" (ngSubmit)=\"submitReactive()\">",
      "      <input formControlName=\"email\" placeholder=\"Reactive email\" />",
      "    </form>",
      "",
      "    <!-- Template-driven (less controlled) -->",
      "    <form #f=\"ngForm\" (ngSubmit)=\"submitTemplate(f)\">",
      "      <input name=\"email\" ngModel placeholder=\"Template email\" />",
      "    </form>",
      "  `",
      "})",
      "export class FormDemoComponent {",
      "  private readonly fb = inject(FormBuilder);",
      "",
      "  reactiveForm = signal<FormGroup>(this.fb.group({",
      "    email: [\"\", [Validators.required, Validators.email]]",
      "  }));",
      "",
      "  submitReactive() {",
      "    console.log(this.reactiveForm().value);",
      "  }",
      "",
      "  submitTemplate(form: NgForm) {",
      "    console.log(form.value);",
      "  }",
      "}"
    ]
  },
  {
    "id": "structural-directive",
    "name": "Structural Directive Pattern (*ngIf / *ngFor) – DEPRECATED",
    "category": "Component & UI",
    "shortDescription": "DEPRECATED: use @if, @for, @switch instead",
    "description": "DEPRECATED in Angular v21+: Structural directives *ngIf, *ngFor, and *ngSwitch are replaced by built-in control flow blocks (@if, @for, @switch). The old directives manipulated DOM via <ng-template>, but modern Angular uses cleaner control-flow syntax with better performance. See \"Built-in Control Flow: @if, @for, @switch\" for modern equivalents.",
    "relatedPatterns": [
      "control-flow-if-else"
    ],
    "exampleTs": [
      "import { Component, signal } from \"@angular/core\";",
      "",
      "@Component({",
      "  selector: \"app-deprecated-structural\",",
      "  template: `",
      "    <!-- DEPRECATED: Old way with *ngIf -->",
      "    <div *ngIf=\\\"isAdmin()\\\">",
      "      Only admins see this with *ngIf",
      "    </div>",
      "",
      "    <!-- DEPRECATED: Old way with *ngFor -->",
      "    <ul>",
      "      <li *ngFor=\\\"let item of items()\\\">{{ item }}</li>",
      "    </ul>",
      "  `",
      "})",
      "export class DeprecatedStructuralComponent {",
      "  isAdmin = signal(true);",
      "  items = signal(['Item 1', 'Item 2', 'Item 3']);",
      "}",
      "",
      "// MODERN ANGULAR V21 ALTERNATIVE:",
      "// ✓ Use @if instead of *ngIf",
      "// ✓ Use @for instead of *ngFor",
      "// ✓ Use @switch instead of *ngSwitch"
    ],
    "exampleHtml": null
  },
  {
    "id": "control-flow-if-else",
    "name": "Built-in Control Flow: @if, @for, @switch",
    "category": "Component & UI",
    "shortDescription": "Use @if/@else, @for with track, and @switch/@case for modern template control flow.",
    "description": "Angular v21+ introduces built-in control flow blocks (@if, @for, @switch) that replace structural directives (*ngIf, *ngFor, *ngSwitch). These blocks are compiled directly into JavaScript with better type safety, performance optimizations, and cleaner syntax. No need for <ng-template> or trackBy functions.",
    "exampleTs": [
      "import { Component, signal } from \"@angular/core\";",
      "",
      "type UserRole = 'admin' | 'user' | 'guest';",
      "",
      "@Component({",
      "  selector: \"app-modern-flow-control\",",
      "  template: `",
      "    <!-- @if / @else if / @else: Conditional rendering -->",
      "    @if (isLoggedIn()) {",
      "      <div>Welcome {{ userName() }}!</div>",
      "    } @else if (isPending()) {",
      "      <div>Loading...</div>",
      "    } @else {",
      "      <div>Please log in</div>",
      "    }",
      "",
      "    <!-- @for: List rendering with track -->",
      "    @for (item of items(); track item.id) {",
      "      <div class=\\\"item\\\">",
      "        <span>{{ item.name }}</span>",
      "        <button (click)=\\\"remove(item.id)\\\">Remove</button>",
      "      </div>",
      "    } @empty {",
      "      <p>No items available</p>",
      "    }",
      "",
      "    <!-- @switch / @case / @default: Multi-way branching -->",
      "    @switch (role()) {",
      "      @case ('admin') {",
      "        <div>Admin Panel Access</div>",
      "      }",
      "      @case ('user') {",
      "        <div>User Dashboard</div>",
      "      }",
      "      @default {",
      "        <div>Guest View</div>",
      "      }",
      "    }",
      "  `",
      "})",
      "export class ModernFlowControlComponent {",
      "  isLoggedIn = signal(true);",
      "  isPending = signal(false);",
      "  userName = signal('Ana');",
      "  role = signal<UserRole>('admin');",
      "  items = signal<Array<{ id: number; name: string }>>([",
      "    { id: 1, name: 'Item 1' },",
      "    { id: 2, name: 'Item 2' },",
      "    { id: 3, name: 'Item 3' }",
      "  ]);",
      "",
      "  remove(id: number) {",
      "    this.items.update(items => items.filter(item => item.id !== id));",
      "  }",
      "}"
    ]
  },
  {
    "id": "attribute-directive",
    "name": "Attribute Directive Pattern",
    "category": "Component & UI",
    "shortDescription": "Attach behavior or styles to existing elements.",
    "description": "Attribute directives (like a custom appHighlight) modify host element appearance or behavior. In Angular v21, use the host object in the decorator to define @HostListener logic and property bindings instead of separate decorators.",
    "exampleTs": [
      "import { Directive, ElementRef, inject } from \"@angular/core\";",
      "",
      "@Directive({",
      "  selector: \"[appHighlight]\",",
      "  host: {",
      "    '(mouseenter)': 'onEnter()',",
      "    '(mouseleave)': 'onLeave()',",
      "    '[style.backgroundColor]': 'bgColor'",
      "  }",
      "})",
      "export class HighlightDirective {",
      "  private readonly el = inject(ElementRef);",
      "  bgColor = 'yellow';",
      "",
      "  onEnter() {",
      "    this.bgColor = 'gold';",
      "  }",
      "",
      "  onLeave() {",
      "    this.bgColor = 'yellow';",
      "  }",
      "}"
    ],
    "exampleHtml": ["<p appHighlight>Highlighted text</p>"]
  },
  {
    "id": "renderless-components",
    "name": "Renderless / Headless Components",
    "category": "Component & UI",
    "shortDescription": "Provide behavior, leave the markup to the consumer.",
    "description": "Renderless components or directives expose state and events (e.g., dropdown open/close) without enforcing a specific DOM structure.",
    "exampleTs": [
      "import { Directive, Signal, signal } from \"@angular/core\";",
      "",
      "@Directive({",
      "  selector: \"[appDropdownLogic]\",",
      "  exportAs: \"dropdown\"",
      "})",
      "export class DropdownLogicDirective {",
      "  private readonly _isOpen = signal(false);",
      "  readonly isOpen: Signal<boolean> = this._isOpen.asReadonly();",
      "",
      "  toggle() {",
      "    this._isOpen.update(v => !v);",
      "  }",
      "}"
    ],
    "exampleHtml": [
      "<div appDropdownLogic #dd=\"dropdown\">",
      "  <button (click)=\"dd.toggle()\">Toggle</button>",
      "  <div @if=\"dd.isOpen()\">",
      "    Projected dropdown content...",
      "  </div>",
      "</div>"
    ]
  },
  {
    "id": "provider-context",
    "name": "Provider / Injected Context Pattern",
    "category": "Component & UI",
    "shortDescription": "Use Angular DI hierarchy as a context system.",
    "description": "Provide a service at a component level to create a context that all descendants can inject, avoiding prop drilling.",
    "exampleTs": [
      "import { Component, Injectable, inject, signal } from \"@angular/core\";",
      "",
      "@Injectable()",
      "export class ThemeService {",
      "  readonly theme = signal<'light' | 'dark'>('light');",
      "",
      "  toggle() {",
      "    this.theme.update(t => t === 'light' ? 'dark' : 'light');",
      "  }",
      "}",
      "",
      "@Component({",
      "  selector: \"app-theme-shell\",",
      "  providers: [ThemeService],",
      "  template: `",
      "    <button (click)=\"toggle()\">Toggle theme</button>",
      "    <ng-content></ng-content>",
      "  `",
      "})",
      "export class ThemeShellComponent {",
      "  private readonly theme = inject(ThemeService);",
      "",
      "  toggle() {",
      "    this.theme.toggle();",
      "  }",
      "}"
    ],
    "exampleHtml": null
  },
  {
    "id": "standalone-components",
    "name": "Standalone Component Architecture",
    "category": "Component & UI",
    "shortDescription": "Feature components without NgModules.",
    "description": "Standalone components with route-level lazy loading simplify architecture and make features more tree-shakeable.",
    "exampleTs": [
      "import { Component } from \"@angular/core\";",
      "",
      "@Component({",
      "  selector: \"app-hello\",",
      "  template: \"Hello {{ name }}!\"",
      "})",
      "export class HelloComponent {",
      "  name = \"world\";",
      "}"
    ]
  },
  {
    "id": "ngrx-store",
    "name": "NgRx Store Pattern",
    "category": "State & Data",
    "shortDescription": "Redux-style global state for Angular.",
    "description": "Centralize state and state changes in a single store using actions, reducers, and selectors; components subscribe to derived slices.",
    "exampleTs": [
      "import { createAction, createReducer, on } from \"@ngrx/store\";",
      "import { Store } from \"@ngrx/store\";",
      "import { Component, inject } from \"@angular/core\";",
      "",
      "export const increment = createAction(\"[Counter] Increment\");",
      "",
      "export const counterReducer = createReducer(",
      "  0,",
      "  on(increment, state => state + 1)",
      ");",
      "",
      "@Component({",
      "  selector: \"app-counter\",",
      "  template: `",
      "    <p>Count: {{ counter$ | async }}</p>",
      "    <button (click)=\"inc()\">Increment</button>",
      "  `",
      "})",
      "export class CounterComponent {",
      "  private readonly store = inject(Store);",
      "  counter$ = this.store.select(\"counter\");",
      "",
      "  inc() {",
      "    this.store.dispatch(increment());",
      "  }",
      "}"
    ]
  },
  {
    "id": "component-store",
    "name": "Component Store Pattern",
    "category": "State & Data",
    "shortDescription": "Local, component-scoped state containers.",
    "description": "NgRx Component Store offers a small, observable state container ideal for feature or component-level state.",
    "exampleTs": [
      "interface TodosState {",
      "  todos: string[];",
      "}",
      "",
      "@Injectable()",
      "export class TodosStore extends ComponentStore<TodosState> {",
      "  readonly todos$ = this.select(state => state.todos);",
      "",
      "  readonly addTodo = this.updater((state, todo: string) => ({",
      "    ...state,",
      "    todos: [...state.todos, todo]",
      "  }));",
      "",
      "  constructor() {",
      "    super({ todos: [] });",
      "  }",
      "}",
      "",
      "@Component({",
      "  selector: \"app-todos\",",
      "  providers: [TodosStore],",
      "  template: `",
      "    <input #t />",
      "    <button (click)=\"store.addTodo(t.value)\">Add</button>",
      "    <ul>",
      "      @for (todo of store.todos$ | async; track todo) {",
      "        <li>{{ todo }}</li>",
      "      }",
      "    </ul>",
      "  `",
      "})",
      "export class TodosComponent {",
      "  readonly store = inject(TodosStore);",
      "}"
    ]
  },
  {
    "id": "behavior-subject-service",
    "name": "Service with BehaviorSubject",
    "category": "State & Data",
    "shortDescription": "Shared state in a service with BehaviorSubject.",
    "description": "Expose app-wide or feature-wide state in a service. In Angular v21+, prefer signals over BehaviorSubject where possible for simpler, more performant state management. Use BehaviorSubject primarily for RxJS composition patterns. See \"Signal-based State Service\" for the modern default pattern.",
    "relatedPatterns": [
      "signal-state-service"
    ],
    "exampleTs": [
      "import { Injectable, signal } from \"@angular/core\";",
      "",
      "export interface AuthUser {",
      "  id: number;",
      "  name: string;",
      "}",
      "",
      "@Injectable({ providedIn: \"root\" })",
      "export class AuthService {",
      "  readonly user = signal<AuthUser | null>(null);",
      "",
      "  login(user: AuthUser) {",
      "    this.user.set(user);",
      "  }",
      "",
      "  logout() {",
      "    this.user.set(null);",
      "  }",
      "}"
    ]
  },
  {
    "id": "signal-state-service",
    "name": "Signal-based State Service",
    "category": "State & Data",
    "shortDescription": "Use signals and computed for local or shared app state.",
    "description": "In Angular v21, signals are a first-class state management option for many feature and app-level scenarios. A service can expose writable signals, computed derived state, and intent-style methods to update state predictably without boilerplate reducers.",
    "exampleTs": [
      "import { Injectable, computed, signal } from \"@angular/core\";",
      "",
      "interface Todo {",
      "  id: number;",
      "  title: string;",
      "  done: boolean;",
      "}",
      "",
      "@Injectable({ providedIn: \"root\" })",
      "export class TodosState {",
      "  private readonly todos = signal<Todo[]>([]);",
      "",
      "  readonly items = this.todos.asReadonly();",
      "  readonly pendingCount = computed(() => this.todos().filter(t => !t.done).length);",
      "",
      "  add(title: string) {",
      "    this.todos.update(current => [",
      "      ...current,",
      "      { id: Date.now(), title, done: false }",
      "    ]);",
      "  }",
      "",
      "  toggle(id: number) {",
      "    this.todos.update(current =>",
      "      current.map(todo => (todo.id === id ? { ...todo, done: !todo.done } : todo))",
      "    );",
      "  }",
      "}"
    ]
  },
  {
    "id": "mvvm",
    "name": "MVVM (Components + Services)",
    "category": "State & Data",
    "shortDescription": "ViewModel services drive the template state.",
    "description": "Move stateful logic into a ViewModel service that components consume. Modern ViewModel patterns in Angular v21 expose signals or computed properties rather than pure observables, simplifying template binding and change detection.",
    "exampleTs": [
      "import { Injectable, inject } from \"@angular/core\";",
      "import { HttpClient } from \"@angular/common/http\";",
      "import { Observable } from \"rxjs\";",
      "import { Component } from \"@angular/core\";",
      "",
      "interface Profile {",
      "  name: string;",
      "  email: string;",
      "}",
      "",
      "@Injectable()",
      "export class ProfileViewModel {",
      "  private readonly http = inject(HttpClient);",
      "  profile$: Observable<Profile> = this.http.get<Profile>(\"/api/profile\");",
      "}",
      "",
      "@Component({",
      "  selector: \"app-profile\",",
      "  providers: [ProfileViewModel],",
      "  template: `",
      "    @if (vm.profile$ | async; as p) {",
      "      <h2>{{ p.name }}</h2>",
      "      <p>{{ p.email }}</p>",
      "    }",
      "  `",
      "})",
      "export class ProfileComponent {",
      "  readonly vm = inject(ProfileViewModel);",
      "}"
    ]
  },
  {
    "id": "command-service",
    "name": "Command Pattern with Services",
    "category": "Interaction & Composition",
    "shortDescription": "Wrap user actions in command-style service methods.",
    "description": "Encapsulate user-triggered operations in services (AddToCartCommand, SaveProfileCommand) to keep components thin and testable.",
    "exampleTs": [
      "import { Injectable, inject } from \"@angular/core\";",
      "import { HttpClient } from \"@angular/common/http\";",
      "import { Observable } from \"rxjs\";",
      "import { Component } from \"@angular/core\";",
      "",
      "@Injectable({ providedIn: \"root\" })",
      "export class CartCommands {",
      "  private readonly http = inject(HttpClient);",
      "",
      "  addToCart(productId: number): Observable<void> {",
      "    return this.http.post<void>(\"/api/cart\", { productId });",
      "  }",
      "}",
      "",
      "@Component({",
      "  selector: \"app-product\",",
      "  template: `",
      "    <button (click)=\"add(1)\">Add to cart</button>",
      "  `",
      "})",
      "export class ProductComponent {",
      "  private readonly commands = inject(CartCommands);",
      "",
      "  add(id: number) {",
      "    this.commands.addToCart(id).subscribe();",
      "  }",
      "}"
    ]
  },
  {
    "id": "mediator-coordinator",
    "name": "Mediator Pattern with Coordinator Service",
    "category": "Interaction & Composition",
    "shortDescription": "Coordinate interaction between sibling components.",
    "description": "A mediator service coordinates events between multiple independent components (e.g., filters and charts in a dashboard).",
    "exampleTs": [
      "import { Injectable, inject, signal } from \"@angular/core\";",
      "import { Component } from \"@angular/core\";",
      "",
      "@Injectable({ providedIn: \"root\" })",
      "export class DashboardMediator {",
      "  private readonly refreshSignal = signal<void>(undefined, { equal: () => false });",
      "",
      "  requestRefresh() {",
      "    this.refreshSignal.set(undefined);",
      "  }",
      "}",
      "",
      "@Component({",
      "  selector: \"app-filter\",",
      "  template: `",
      "    <button (click)=\"applyFilter()\">Apply filter</button>",
      "  `",
      "})",
      "export class FilterComponent {",
      "  private readonly mediator = inject(DashboardMediator);",
      "",
      "  applyFilter() {",
      "    this.mediator.requestRefresh();",
      "  }",
      "}",
      "",
      "@Component({",
      "  selector: \"app-chart\",",
      "  template: `",
      "    <p>Chart data...</p>",
      "  `",
      "})",
      "export class ChartComponent {",
      "  private readonly mediator = inject(DashboardMediator);",
      "}"
    ]
  },
  {
    "id": "strategy-injection-token",
    "name": "Strategy Pattern via Injection Tokens",
    "category": "Interaction & Composition",
    "shortDescription": "Swap algorithms by providing different services.",
    "description": "Define a strategy interface and use DI tokens to inject different implementations (e.g., StripeStrategy vs PaypalStrategy).",
    "exampleTs": [
      "import { Injectable, InjectionToken, inject, Component } from \"@angular/core\";",
      "",
      "export interface PaymentStrategy {",
      "  pay(amount: number): void;",
      "}",
      "",
      "@Injectable()",
      "export class PaypalStrategy implements PaymentStrategy {",
      "  pay(amount: number) {",
      "    console.log(\"PayPal payment\", amount);",
      "  }",
      "}",
      "",
      "@Injectable()",
      "export class StripeStrategy implements PaymentStrategy {",
      "  pay(amount: number) {",
      "    console.log(\"Stripe payment\", amount);",
      "  }",
      "}",
      "",
      "export const PAYMENT_STRATEGY = new InjectionToken<PaymentStrategy>(\"PAYMENT_STRATEGY\");",
      "",
      "@Component({",
      "  selector: \"app-checkout\",",
      "  providers: [",
      "    { provide: PAYMENT_STRATEGY, useClass: PaypalStrategy }",
      "  ],",
      "  template: `",
      "    <button (click)=\"checkout()\">Checkout</button>",
      "  `",
      "})",
      "export class CheckoutComponent {",
      "  private readonly strategy = inject(PAYMENT_STRATEGY);",
      "",
      "  checkout() {",
      "    this.strategy.pay(100);",
      "  }",
      "}"
    ]
  },
  {
    "id": "template-method-base-class",
    "name": "Template Method Pattern via Base Classes",
    "category": "Interaction & Composition",
    "shortDescription": "Base component defines algorithm skeleton.",
    "description": "Abstract base components implement shared algorithm steps and rely on subclasses to override key hooks.",
    "exampleTs": [
      "import { Component, OnInit, inject } from \"@angular/core\";",
      "import { HttpClient } from \"@angular/common/http\";",
      "import { Observable } from \"rxjs\";",
      "",
      "export abstract class ListBaseComponent<T> implements OnInit {",
      "  items: T[] = [];",
      "",
      "  abstract fetchItems(): Observable<T[]>;",
      "",
      "  ngOnInit() {",
      "    this.fetchItems().subscribe(items => (this.items = items));",
      "  }",
      "}",
      "",
      "interface UserBase {",
      "  id: number;",
      "  name: string;",
      "}",
      "",
      "@Component({",
      "  selector: \"app-user-list-base\",",
      "  template: `",
      "    <ul>",
      "      @for (u of items; track u.id) {",
      "        <li>{{ u.name }}</li>",
      "      }",
      "    </ul>",
      "  `",
      "})",
      "export class UserListBaseComponent extends ListBaseComponent<UserBase> {",
      "  private readonly http = inject(HttpClient);",
      "",
      "  fetchItems(): Observable<UserBase[]> {",
      "    return this.http.get<UserBase[]>(\"/api/users\");",
      "  }",
      "}"
    ]
  },
  {
    "id": "chain-of-responsibility-interceptors",
    "name": "Chain of Responsibility (HTTP Interceptors)",
    "category": "Interaction & Composition",
    "shortDescription": "Chain HTTP request/response handlers.",
    "description": "Multiple HTTP interceptors each handle part of a request/response, forming a chain similar to Chain of Responsibility.",
    "exampleTs": [
      "import { HttpInterceptorFn } from \"@angular/common/http\";",
      "",
      "export const authInterceptor: HttpInterceptorFn = (req, next) => {",
      "  const cloned = req.clone({",
      "    setHeaders: { Authorization: \"Bearer token\" }",
      "  });",
      "  return next(cloned);",
      "};",
      "",
      "export const loggingInterceptor: HttpInterceptorFn = (req, next) => {",
      "  console.log(\"Request\", req.url);",
      "  return next(req);",
      "};"
    ]
  },
  {
    "id": "adapter-service",
    "name": "Adapter Pattern via Services",
    "category": "Interaction & Composition",
    "shortDescription": "Normalize awkward backend APIs.",
    "description": "Adapter services translate backend API shapes into clean frontend models so components remain unaffected by backend quirks.",
    "exampleTs": [
      "import { Injectable, inject } from \"@angular/core\";",
      "import { HttpClient } from \"@angular/common/http\";",
      "import { map, Observable } from \"rxjs\";",
      "",
      "interface ApiUser {",
      "  first_name: string;",
      "  last_name: string;",
      "}",
      "",
      "export interface User {",
      "  fullName: string;",
      "}",
      "",
      "@Injectable({ providedIn: \"root\" })",
      "export class UserAdapterService {",
      "  private readonly http = inject(HttpClient);",
      "",
      "  getUsers(): Observable<User[]> {",
      "    return this.http.get<ApiUser[]>(\"/api/users\").pipe(",
      "      map(apiUsers =>",
      "        apiUsers.map(u => ({ fullName: `${u.first_name} ${u.last_name}` }))",
      "      )",
      "    );",
      "  }",
      "}"
    ]
  },
  {
    "id": "onpush-change-detection",
    "name": "OnPush Change Detection",
    "category": "Rendering & Performance",
    "shortDescription": "Render only when inputs or observables change.",
    "description": "ChangeDetectionStrategy.OnPush optimizes performance by skipping checks unless input() values change, output() events are triggered, or signals/observables emit. Always pair with input() functions rather than @Input() decorators for best results.",
    "exampleTs": [
      "import { Component, ChangeDetectionStrategy, input } from \"@angular/core\";",
      "",
      "@Component({",
      "  selector: \"app-user-card\",",
      "  changeDetection: ChangeDetectionStrategy.OnPush,",
      "  template: `",
      "    {{ user().name }}",
      "  `",
      "})",
      "export class UserCardComponent {",
      "  user = input.required<{ name: string }>();",
      "}"
    ]
  },
  {
    "id": "trackby-ngfor",
    "name": "trackBy for *ngFor – DEPRECATED",
    "category": "Rendering & Performance",
    "shortDescription": "DEPRECATED: use @for with track instead",
    "description": "DEPRECATED in Angular v21+: Manual trackBy functions with *ngFor are replaced by @for's built-in track expressions. Use @for (item of items; track item.id) for superior performance, simpler syntax, and automatic optimization without needing explicit trackBy methods.",
    "exampleTs": [
      "// ❌ OLD DEPRECATED WAY (*ngFor with trackBy)",
      "import { Component } from \\\"@angular/core\\\";",
      "",
      "interface Item { id: number; name: string; }",
      "",
      "@Component({",
      "  selector: \\\"app-items-old\\\",",
      "  imports: [NgFor],",
      "  template: `<li *ngFor=\\\"let item of items; trackBy: trackById\\\">{{item.name}}</li>`",
      "})",
      "export class ItemsOldComponent {",
      "  items = [{ id: 1, name: 'A' }, { id: 2, name: 'B' }];",
      "",
      "  trackById(index: number, item: Item): number {",
      "    return item.id;",
      "  }",
      "}",
      "",
      "// ✅ NEW WAY (@for with track)",
      "import { Component, signal } from \\\"@angular/core\\\";",
      "",
      "@Component({",
      "  selector: \\\"app-items-new\\\",",
      "  template: `@for (item of items(); track item.id) { <li>{{item.name}}</li> }`",
      "})",
      "export class ItemsNewComponent {",
      "  items = signal<Item[]>([{ id: 1, name: 'A' }, { id: 2, name: 'B' }]);",
      "}"
    ],
    "exampleHtml": null
  },
  {
    "id": "control-flow-for",
    "name": "Built-in Control Flow: @for",
    "category": "Rendering & Performance",
    "shortDescription": "Use @for with track expressions instead of *ngFor / trackBy.",
    "description": "Angular's built-in @for block replaces *ngFor and accepts an inline track expression, offering a faster diffing algorithm and cleaner syntax.",
    "exampleTs": [
      "import { Component, signal } from \"@angular/core\";",
      "",
      "interface Item {",
      "  id: number;",
      "  name: string;",
      "}",
      "",
      "@Component({",
      "  selector: \"app-items-for\",",
      "  template: `",
      "    @for (item of items(); track item.id) {",
      "      <div>{{ item.name }}</div>",
      "    }",
      "  `",
      "})",
      "export class ItemsForComponent {",
      "  items = signal<Item[]>([",
      "    { id: 1, name: \"One\" },",
      "    { id: 2, name: \"Two\" }",
      "  ]);",
      "}"
    ]
  },
  {
    "id": "virtual-scroll-cdk",
    "name": "Virtual Scrolling (CDK)",
    "category": "Rendering & Performance",
    "shortDescription": "Render only the visible slice of long lists.",
    "description": "Angular CDK virtual scroll shows just the visible portion of a long list to reduce DOM size.",
    "exampleTs": [
      "import { Component, signal } from \"@angular/core\";",
      "import { ScrollingModule } from \"@angular/cdk/scrolling\";",
      "",
      "@Component({",
      "  selector: \"app-virtual-list\",",
      "  imports: [ScrollingModule],",
      "  template: `",
      "    <cdk-virtual-scroll-viewport itemSize=\\\"50\\\" style=\\\"height: 300px\\\">",
      "      <div *cdkVirtualFor=\\\"let item of items()\\\">{{ item }}</div>",
      "    </cdk-virtual-scroll-viewport>",
      "  `",
      "})",
      "export class VirtualListComponent {",
      "  items = signal(Array.from({ length: 1000 }).map((_, i) => `Item ${i}`));",
      "}"
    ]
  },
  {
    "id": "lazy-loading-routes",
    "name": "Lazy Loading Routes & Data",
    "category": "Rendering & Performance",
    "shortDescription": "Load feature code and data only when needed.",
    "description": "Lazy route configuration with loadChildren or loadComponent delays loading of feature bundles until the route is visited. Combine with lazy data loading for smaller initial bundle and faster startup.",
    "exampleTs": [
      "// 1. Lazy-load routes with loadComponent",
      "import { Routes } from \"@angular/router\";",
      "",
      "export const routes: Routes = [",
      "  { path: 'feature', loadComponent: () => import('./feature/feature.component').then(m => m.FeatureComponent) }",
      "];",
      "",
      "// 2. Lazy-load data with a facade service + caching",
      "import { Injectable, signal } from \"@angular/core\";",
      "",
      "@Injectable({ providedIn: 'root' })",
      "export class LazyDataService {",
      "  private readonly cache = new Map<string, any[]>();",
      "",
      "  async loadData(feature: string): Promise<any[]> {",
      "    if (this.cache.has(feature)) return this.cache.get(feature)!;",
      "    const data = await import(`./data/${feature}.data`)",
      "      .then(m => m[`${feature.toUpperCase()}_DATA`]);",
      "    this.cache.set(feature, data);",
      "    return data;",
      "  }",
      "}",
      "",
      "// 3. Component uses lazy data",
      "@Component({",
      "  selector: 'app-feature-list',",
      "  template: `<li *ngFor=\\\"let item of items()\\\">{{ item.name }}</li>`",
      "})",
      "export class FeatureListComponent {",
      "  readonly items = signal<any[]>([]);",
      "  constructor(private dataService: LazyDataService) {",
      "    this.dataService.loadData('feature').then(data => this.items.set(data));",
      "  }",
      "}"
    ]
  },
  {
    "id": "debounce-throttle-rxjs",
    "name": "Debounce / Throttle with RxJS",
    "category": "Rendering & Performance",
    "shortDescription": "Limit how often expensive logic runs.",
    "description": "Use debounceTime, throttleTime, and distinctUntilChanged to avoid flooding the UI with updates from rapid events (typing, scrolling).",
    "exampleTs": [
      "import { Component, signal, effect } from \"@angular/core\";",
      "import { debounceTime, Subject } from \"rxjs\";",
      "",
      "@Component({",
      "  selector: \"app-search\",",
      "  template: `",
      "    <input (input)=\\\"search$.next($any($event.target).value)\\\" placeholder=\\\"Search\\\" />",
      "  `",
      "})",
      "export class SearchComponent {",
      "  search$ = new Subject<string>();",
      "",
      "  constructor() {",
      "    this.search$",
      "      .pipe(debounceTime(300))",
      "      .subscribe(value => console.log(\\\"Search for\\\", value));",
      "  }",
      "}"
    ]
  },
  {
    "id": "facade",
    "name": "Facade Pattern",
    "category": "API & Data Integration",
    "shortDescription": "One simple API for complex underlying layers.",
    "description": "A facade service wraps NgRx, repositories, and HTTP calls behind a simple, UI-friendly interface.",
    "exampleTs": [
      "import { Injectable, inject } from \"@angular/core\";",
      "import { Store } from \"@ngrx/store\";",
      "import { Observable } from \"rxjs\";",
      "",
      "import { Product } from \"./product.model\";",
      "import { loadProducts, addProduct } from \"./product.actions\";",
      "import { selectProducts, selectProductsLoading } from \"./product.selectors\";",
      "",
      "@Injectable({ providedIn: \"root\" })",
      "export class ProductsFacade {",
      "  private readonly store = inject(Store);",
      "",
      "  products$: Observable<Product[]> = this.store.select(selectProducts);",
      "  loading$: Observable<boolean> = this.store.select(selectProductsLoading);",
      "",
      "  loadProducts() {",
      "    this.store.dispatch(loadProducts());",
      "  }",
      "",
      "  addProduct(product: Product) {",
      "    this.store.dispatch(addProduct({ product }));",
      "  }",
      "}"
    ]
  },
  {
    "id": "repository",
    "name": "Repository Pattern",
    "category": "API & Data Integration",
    "shortDescription": "Abstract persistence and HTTP access.",
    "description": "Repository services encapsulate fetching, caching, and mapping data so the rest of the app deals with domain models only.",
    "exampleTs": [
      "import { Injectable, inject } from \"@angular/core\";",
      "import { HttpClient } from \"@angular/common/http\";",
      "import { Observable } from \"rxjs\";",
      "",
      "export interface ProductRepoModel {",
      "  id: string;",
      "  name: string;",
      "}",
      "",
      "@Injectable({ providedIn: \"root\" })",
      "export class ProductRepository {",
      "  private readonly http = inject(HttpClient);",
      "",
      "  getProducts(): Observable<ProductRepoModel[]> {",
      "    return this.http.get<ProductRepoModel[]>(\"/api/products\");",
      "  }",
      "}"
    ]
  },
  {
    "id": "ngrx-effects",
    "name": "Effects Pattern (NgRx Effects)",
    "category": "API & Data Integration",
    "shortDescription": "Side-effectful async operations for the store.",
    "description": "NgRx Effects run async logic (HTTP calls, logging, routing) in response to actions, separate from reducers and components.",
    "exampleTs": [
      "import { Injectable, inject } from \"@angular/core\";",
      "import { Actions, createEffect, ofType } from \"@ngrx/effects\";",
      "import { HttpClient } from \"@angular/common/http\";",
      "import { catchError, map, of, switchMap } from \"rxjs\";",
      "",
      "import {",
      "  loadProducts,",
      "  loadProductsSuccess,",
      "  loadProductsFailure",
      "} from \"./product.actions\";",
      "import { Product } from \"./product.model\";",
      "",
      "@Injectable()",
      "export class ProductsEffects {",
      "  private readonly actions$ = inject(Actions);",
      "  private readonly http = inject(HttpClient);",
      "",
      "  loadProducts$ = createEffect(() =>",
      "    this.actions$.pipe(",
      "      ofType(loadProducts),",
      "      switchMap(() =>",
      "        this.http.get<Product[]>(\"/api/products\").pipe(",
      "          map(products => loadProductsSuccess({ products })),",
      "          catchError(() => of(loadProductsFailure()))",
      "        )",
      "      )",
      "    )",
      "  );",
      "}"
    ]
  },
  {
    "id": "dependency-injection",
    "name": "Dependency Injection (DI)",
    "category": "Core / Architectural",
    "shortDescription": "Supply dependencies from the outside using Angular DI.",
    "description": "Dependency Injection in Angular uses injectors and providers so components and services receive ready-to-use dependencies instead of constructing them manually.",
    "exampleTs": [
      "import { Injectable, inject } from \"@angular/core\";",
      "import { Component } from \"@angular/core\";",
      "",
      "@Injectable({ providedIn: \"root\" })",
      "export class LoggerService {",
      "  log(msg: string) {",
      "    console.log(\\\"[LOG]\\\", msg);",
      "  }",
      "}",
      "",
      "@Component({",
      "  selector: \"app-home\",",
      "  template: `",
      "    <button (click)=\\\"sayHi()\\\">Say hi</button>",
      "  `",
      "})",
      "export class HomeComponent {",
      "  private readonly logger = inject(LoggerService);",
      "",
      "  sayHi() {",
      "    this.logger.log(\\\"Hello from HomeComponent\\\");",
      "  }",
      "}"
    ]
  },
  {
    "id": "pipe-pattern",
    "name": "Pipe Pattern",
    "category": "Rendering & Performance",
    "shortDescription": "Transform data in templates using pipes.",
    "description": "Use Angular pipes to format and transform data directly in templates, keeping components clean.",
    "exampleTs": [
      "import { Component, signal } from '@angular/core';",
      "",
      "@Component({",
      "  selector: 'app-date-pipe',",
      "  template: `",
      "    <p>{{ today() | date }}</p>",
      "  `",
      "})",
      "export class DatePipeComponent {",
      "  today = signal(new Date());",
      "}"
    ]
  },
  {
    "id": "rxjs-observable-pattern",
    "name": "RxJS Observable Pattern",
    "category": "State & Data",
    "shortDescription": "Use RxJS observables for reactive data streams.",
    "description": "Leverage RxJS observables to handle asynchronous data streams in Angular applications.",
    "exampleTs": [
      "import { Component, signal, OnDestroy } from '@angular/core';",
      "import { interval, Subscription } from 'rxjs';",
      "",
      "@Component({",
      "  selector: 'app-timer',",
      "  template: `",
      "    <p>Seconds: {{ seconds() }}</p>",
      "  `",
      "})",
      "export class TimerComponent implements OnDestroy {",
      "  seconds = signal(0);",
      "  private subscription: Subscription;",
      "",
      "  constructor() {",
      "    this.subscription = interval(1000).subscribe(val => this.seconds.set(val));",
      "  }",
      "",
      "  ngOnDestroy() {",
      "    this.subscription.unsubscribe();",
      "  }",
      "}"
    ]
  },
  {
    "id": "async-pipe-pattern",
    "name": "Async Pipe Pattern",
    "category": "Rendering & Performance",
    "shortDescription": "Use the async pipe to handle observables in templates.",
    "description": "The async pipe automatically subscribes to observables and unsubscribes when the component is destroyed.",
    "exampleTs": [
      "import { Component, signal } from '@angular/core';",
      "",
      "@Component({",
      "  selector: 'app-async-pipe',",
      "  template: `",
      "    <p>{{ data() }}</p>",
      "  `",
      "})",
      "export class AsyncPipeComponent {",
      "  data = signal('Hello, Async Pipe!');",
      "}"
    ]
  },
  {
    "id": "class-decorators",
    "name": "Decorator Pattern via Class Decorators",
    "category": "Interaction & Composition",
    "shortDescription": "Decorators add metadata/behavior to classes.",
    "description": "Angular decorators like @Component and @Injectable are special cases; custom decorators can also wrap or log component behavior.",
    "exampleTs": [
      "import { Component } from '@angular/core';",
      "",
      "function LogClass(constructor: Function) {",
      "  console.log('Component created:', constructor.name);",
      "}",
      "",
      "@LogClass",
      "@Component({",
      "  selector: 'app-logged',",
      "  template: `I am logged`",
      "})",
      "export class LoggedComponent {}"
    ]
  }
]
