[
  {
    "id": "container-presenter",
    "name": "Container–Presenter Components",
    "category": "Component & UI",
    "shortDescription": "Split smart (data) and dumb (view-only) components.",
    "description": "A container component handles state, services, and data fetching, while a presenter component receives data via @Input() and emits user events via @Output(), keeping UI simple and testable.",
    "exampleTs": [
      "import { Component, EventEmitter, Input, Output } from \"@angular/core\";",
      "",
      "@Component({",
      "  selector: \"app-user-list-container\",",
      "  standalone: true,",
      "  imports: [UserListComponent],",
      "  template: `",
      "    <app-user-list",
      "      [users]=\"users\"",
      "      (selectUser)=\"onSelect($event)\">",
      "    </app-user-list>",
      "  `",
      "})",
      "export class UserListContainerComponent {",
      "  users = [\"Ana\", \"Bruno\", \"Carlos\"];",
      "",
      "  onSelect(user: string) {",
      "    console.log(\"Selected\", user);",
      "  }",
      "}",

      "@Component({",
      "  selector: \"app-user-list\",",
      "  standalone: true,",
      "  template: `",
      "    <ul>",
      "      <li @for=\"let u of users\" (click)=\"selectUser.emit(u)\">",
      "        {{ u }}",
      "      </li>",
      "    </ul>",
      "  `",
      "})",
      "export class UserListComponent {",
      "  @Input() users: string[] = [];",
      "  @Output() selectUser = new EventEmitter<string>();",
      "}"
    ]
  },
  {
    "id": "compound-components",
    "name": "Compound Components via Content Projection",
    "category": "Component & UI",
    "shortDescription": "Parent component coordinates projected child UIs.",
    "description": "Expose multiple sub-areas (header, body, footer, etc.) through <ng-content> and let consumers assemble complex UIs while the parent manages behavior.",
    "exampleTs": [
      "import { Component } from \"@angular/core\";",
      "",
      "@Component({",
      "  selector: \"app-card\",",
      "  standalone: true,",
      "  template: `",
      "    <div class=\\\"card\\\">",
      "      <div class=\\\"card-header\\\">",
      "        <ng-content select=\\\"[card-title]\\\"></ng-content>",
      "      </div>",
      "      <div class=\\\"card-body\\\">",
      "        <ng-content select=\\\"[card-body]\\\"></ng-content>",
      "      </div>",
      "      <div class=\\\"card-footer\\\">",
      "        <ng-content select=\\\"[card-footer]\\\"></ng-content>",
      "      </div>",
      "    </div>",
      "  `",
      "})",
      "export class CardComponent {}"
    ],
    "exampleHtml": [
      "<app-card>",
      "  <h2 card-title>Profile</h2>",
      "  <div card-body>Body content…</div>",
      "  <button card-footer>Save</button>",
      "</app-card>"
    ]
  },
  {
    "id": "reactive-vs-template-forms",
    "name": "Controlled vs. Uncontrolled (Reactive vs Template-Driven)",
    "category": "Component & UI",
    "shortDescription": "Compare reactive (controlled) and template-driven (less controlled) forms.",
    "description": "Reactive forms centralize form state in TypeScript and treat the UI as a projection of that state, while template-driven forms rely on template directives and implicit form models.",
    "exampleTs": [
      "import { Component } from \"@angular/core\";",
      "import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from \"@angular/forms\";",
      "import { FormsModule, NgForm } from \"@angular/forms\";",
      "",
      "@Component({",
      "  selector: \"app-form-demo\",",
      "  standalone: true,",
      "  imports: [ReactiveFormsModule, FormsModule],",
      "  template: `",
      "    <!-- Reactive (controlled) -->",
      "    <form [formGroup]=\"reactiveForm\" (ngSubmit)=\"submitReactive()\">",
      "      <input formControlName=\"email\" placeholder=\"Reactive email\" />",
      "    </form>",
      "",
      "    <!-- Template-driven (less controlled) -->",
      "    <form #f=\"ngForm\" (ngSubmit)=\"submitTemplate(f)\">",
      "      <input name=\"email\" ngModel placeholder=\"Template email\" />",
      "    </form>",
      "  `",
      "})",
      "export class FormDemoComponent {",
      "  reactiveForm: FormGroup;",
      "",
      "  constructor(private fb: FormBuilder) {",
      "    this.reactiveForm = this.fb.group({",
      "      email: [\"\", [Validators.required, Validators.email]]",
      "    });",
      "  }",
      "",
      "  submitReactive() {",
      "    console.log(this.reactiveForm.value);",
      "  }",
      "",
      "  submitTemplate(form: NgForm) {",
      "    console.log(form.value);",
      "  }",
      "}"
    ]
  },
  {
    "id": "structural-directive",
    "name": "Structural Directive Pattern (*ngIf / *ngFor) – DEPRECATED",
    "category": "Component & UI",
    "shortDescription": "DEPRECATED: classic structural directives like *ngIf / *ngFor.",
    "description": "DEPRECATED in favor of Angular's built-in control flow syntax (@if, @for, @switch): structural directives like *ngIf and *ngFor used to add/remove DOM parts, but modern Angular apps should migrate to the new control-flow blocks.",
    "exampleTs": [
      "import { Directive, Input, TemplateRef, ViewContainerRef } from \"@angular/core\";",
      "",
      "@Directive({",
      "  selector: \"[appIfAdmin]\",",
      "  standalone: true",
      "})",
      "export class IfAdminDirective {",
      "  private hasView = false;",
      "",
      "  @Input() set appIfAdmin(isAdmin: boolean) {",
      "    if (isAdmin && !this.hasView) {",
      "      this.vcr.createEmbeddedView(this.tpl);",
      "      this.hasView = true;",
      "    } else if (!isAdmin && this.hasView) {",
      "      this.vcr.clear();",
      "      this.hasView = false;",
      "    }",
      "  }",
      "",
      "  constructor(",
      "    private tpl: TemplateRef<unknown>,",
      "    private vcr: ViewContainerRef",
      "  ) {}",
      "}"
    ],
    "exampleHtml": ["<div *appIfAdmin=\"isAdmin\">", "  Only admins see this block.", "</div>"]
  },
  {
    "id": "control-flow-if-else",
    "name": "Built-in Control Flow: @if / @else",
    "category": "Component & UI",
    "shortDescription": "Use @if, @else, and @else if blocks instead of *ngIf.",
    "description": "Angular 21 introduces built-in control flow where @if, @else if, and @else replace *ngIf for more readable, type-safe template branching without extra <ng-template> gymnastics.",
    "exampleTs": [
      "import { Component } from \"@angular/core\";",
      "",
      "@Component({",
      "  selector: \"app-login-message\",",
      "  standalone: true,",
      "  template: `",
      "    @if (isLoggedIn) {",
      "      <p>Welcome back, {{ userName }}!</p>",
      "    } @else {",
      "      <p>Please log in to continue.</p>",
      "    }",
      "  `",
      "})",
      "export class LoginMessageComponent {",
      "  isLoggedIn = true;",
      "  userName = \"Ana\";",
      "}"
    ]
  },
  {
    "id": "attribute-directive",
    "name": "Attribute Directive Pattern",
    "category": "Component & UI",
    "shortDescription": "Attach behavior or styles to existing elements.",
    "description": "Attribute directives (like a custom appHighlight) modify host element appearance or behavior without changing its component class.",
    "exampleTs": [
      "import { Directive, ElementRef, HostListener } from \"@angular/core\";",
      "",
      "@Directive({",
      "  selector: \"[appHighlight]\",",
      "  standalone: true",
      "})",
      "export class HighlightDirective {",
      "  constructor(private el: ElementRef) {",
      "    this.el.nativeElement.style.backgroundColor = \"yellow\";",
      "  }",
      "",
      "  @HostListener(\"mouseenter\") onEnter() {",
      "    this.el.nativeElement.style.backgroundColor = \"gold\";",
      "  }",
      "",
      "  @HostListener(\"mouseleave\") onLeave() {",
      "    this.el.nativeElement.style.backgroundColor = \"yellow\";",
      "  }",
      "}"
    ],
    "exampleHtml": ["<p appHighlight>Highlighted text</p>"]
  },
  {
    "id": "renderless-components",
    "name": "Renderless / Headless Components",
    "category": "Component & UI",
    "shortDescription": "Provide behavior, leave the markup to the consumer.",
    "description": "Renderless components or directives expose state and events (e.g., dropdown open/close) without enforcing a specific DOM structure.",
    "exampleTs": [
      "import { Directive, Signal, signal } from \"@angular/core\";",
      "",
      "@Directive({",
      "  selector: \"[appDropdownLogic]\",",
      "  exportAs: \"dropdown\",",
      "  standalone: true",
      "})",
      "export class DropdownLogicDirective {",
      "  private _isOpen = signal(false);",
      "  isOpen: Signal<boolean> = this._isOpen.asReadonly();",
      "",
      "  toggle() {",
      "    this._isOpen.update(v => !v);",
      "  }",
      "}"
    ],
    "exampleHtml": [
      "<div appDropdownLogic #dd=\"dropdown\">",
      "  <button (click)=\"dd.toggle()\">Toggle</button>",
      "  <div @if=\"dd.isOpen()\">",
      "    Projected dropdown content...",
      "  </div>",
      "</div>"
    ]
  },
  {
    "id": "provider-context",
    "name": "Provider / Injected Context Pattern",
    "category": "Component & UI",
    "shortDescription": "Use Angular DI hierarchy as a context system.",
    "description": "Provide a service at a component level to create a context that all descendants can inject, avoiding prop drilling.",
    "exampleTs": [
      "import { Component, Injectable, inject } from \"@angular/core\";",
      "import { BehaviorSubject } from \"rxjs\";",
      "",
      "@Injectable()",
      "export class ThemeService {",
      "  private themeSubject = new BehaviorSubject<\"light\" | \"dark\">(\"light\");",
      "  theme$ = this.themeSubject.asObservable();",
      "",
      "  toggle() {",
      "    this.themeSubject.next(",
      "      this.themeSubject.value === \"light\" ? \"dark\" : \"light\"",
      "    );",
      "  }",
      "}",
      "",
      "@Component({",
      "  selector: \"app-theme-shell\",",
      "  standalone: true,",
      "  providers: [ThemeService],",
      "  template: `",
      "    <button (click)=\"toggle()\">Toggle theme</button>",
      "    <ng-content></ng-content>",
      "  `",
      "})",
      "export class ThemeShellComponent {",
      "  private theme = inject(ThemeService);",
      "",
      "  toggle() {",
      "    this.theme.toggle();",
      "  }",
      "}"
    ],
    "exampleHtml": null
  },
  {
    "id": "standalone-components",
    "name": "Standalone Component Architecture",
    "category": "Component & UI",
    "shortDescription": "Feature components without NgModules.",
    "description": "Standalone components with route-level lazy loading simplify architecture and make features more tree-shakeable.",
    "exampleTs": [
      "import { Component } from \"@angular/core\";",
      "",
      "@Component({",
      "  selector: \"app-hello\",",
      "  standalone: true,",
      "  template: \"Hello {{ name }}!\"",
      "})",
      "export class HelloComponent {",
      "  name = \"world\";",
      "}"
    ]
  },
  {
    "id": "ngrx-store",
    "name": "NgRx Store Pattern",
    "category": "State & Data",
    "shortDescription": "Redux-style global state for Angular.",
    "description": "Centralize state and state changes in a single store using actions, reducers, and selectors; components subscribe to derived slices.",
    "exampleTs": [
      "import { createAction, createReducer, on } from \"@ngrx/store\";",
      "import { Store } from \"@ngrx/store\";",
      "import { Component } from \"@angular/core\";",
      "",
      "export const increment = createAction(\"[Counter] Increment\");",
      "",
      "export const counterReducer = createReducer(",
      "  0,",
      "  on(increment, state => state + 1)",
      ");",
      "",
      "@Component({",
      "  selector: \"app-counter\",",
      "  standalone: true,",
      "  template: `",
      "    <p>Count: {{ counter$ | async }}</p>",
      "    <button (click)=\"inc()\">Increment</button>",
      "  `",
      "})",
      "export class CounterComponent {",
      "  counter$ = this.store.select(\"counter\");",
      "",
      "  constructor(private store: Store) {}",
      "",
      "  inc() {",
      "    this.store.dispatch(increment());",
      "  }",
      "}"
    ]
  },
  {
    "id": "component-store",
    "name": "Component Store Pattern",
    "category": "State & Data",
    "shortDescription": "Local, component-scoped state containers.",
    "description": "NgRx Component Store offers a small, observable state container ideal for feature or component-level state.",
    "exampleTs": [
      "interface TodosState {",
      "  todos: string[];",
      "}",
      "",
      "@Injectable()",
      "export class TodosStore extends ComponentStore<TodosState> {",
      "  readonly todos$ = this.select(state => state.todos);",
      "",
      "  readonly addTodo = this.updater((state, todo: string) => ({",
      "    ...state,",
      "    todos: [...state.todos, todo]",
      "  }));",
      "",
      "  constructor() {",
      "    super({ todos: [] });",
      "  }",
      "}",
      "",
      "@Component({",
      "  selector: \"app-todos\",",
      "  standalone: true,",
      "  providers: [TodosStore],",
      "  template: `",
      "    <input #t />",
      "    <button (click)=\"store.addTodo(t.value)\">Add</button>",
      "    <ul>",
      "      <li @for=\"let todo of store.todos$ | async\">",
      "        {{ todo }}",
      "      </li>",
      "    </ul>",
      "  `",
      "})",
      "export class TodosComponent {",
      "  constructor(public store: TodosStore) {}",
      "}"
    ]
  },
  {
    "id": "behavior-subject-service",
    "name": "Service with BehaviorSubject",
    "category": "State & Data",
    "shortDescription": "Shared state in a service with BehaviorSubject.",
    "description": "Expose app-wide or feature-wide state via BehaviorSubject in a service and let consumers subscribe to its observable stream.",
    "exampleTs": [
      "import { Injectable } from \"@angular/core\";",
      "import { BehaviorSubject, Observable } from \"rxjs\";",
      "",
      "export interface AuthUser {",
      "  id: number;",
      "  name: string;",
      "}",
      "",
      "@Injectable({ providedIn: \"root\" })",
      "export class AuthService {",
      "  private userSubject = new BehaviorSubject<AuthUser | null>(null);",
      "  user$: Observable<AuthUser | null> = this.userSubject.asObservable();",
      "",
      "  login(user: AuthUser) {",
      "    this.userSubject.next(user);",
      "  }",
      "",
      "  logout() {",
      "    this.userSubject.next(null);",
      "  }",
      "}"
    ]
  },
  {
    "id": "mvvm",
    "name": "MVVM (Components + Services)",
    "category": "State & Data",
    "shortDescription": "ViewModel services drive the template state.",
    "description": "Treat the component as the View and move stateful logic into a ViewModel service that exposes observables and commands.",
    "exampleTs": [
      "import { Injectable } from \"@angular/core\";",
      "import { HttpClient } from \"@angular/common/http\";",
      "import { Observable } from \"rxjs\";",
      "import { Component } from \"@angular/core\";",
      "import { NgIf } from \"@angular/common\";",
      "",
      "interface Profile {",
      "  name: string;",
      "  email: string;",
      "}",
      "",
      "@Injectable()",
      "export class ProfileViewModel {",
      "  profile$: Observable<Profile> = this.http.get<Profile>(\"/api/profile\");",
      "",
      "  constructor(private http: HttpClient) {}",
      "}",
      "",
      "@Component({",
      "  selector: \"app-profile\",",
      "  standalone: true,",
      "  imports: [NgIf],",
      "  providers: [ProfileViewModel],",
      "  template: `",
      "    <ng-container @if=\"vm.profile$ | async as p\">",
      "      <h2>{{ p.name }}</h2>",
      "      <p>{{ p.email }}</p>",
      "    </ng-container>",
      "  `",
      "})",
      "export class ProfileComponent {",
      "  constructor(public vm: ProfileViewModel) {}",
      "}"
    ]
  },
  {
    "id": "command-service",
    "name": "Command Pattern with Services",
    "category": "Interaction & Composition",
    "shortDescription": "Wrap user actions in command-style service methods.",
    "description": "Encapsulate user-triggered operations in services (AddToCartCommand, SaveProfileCommand) to keep components thin and testable.",
    "exampleTs": [
      "import { Injectable } from \"@angular/core\";",
      "import { HttpClient } from \"@angular/common/http\";",
      "import { Observable } from \"rxjs\";",
      "import { Component } from \"@angular/core\";",
      "",
      "@Injectable({ providedIn: \"root\" })",
      "export class CartCommands {",
      "  constructor(private http: HttpClient) {}",
      "",
      "  addToCart(productId: number): Observable<void> {",
      "    return this.http.post<void>(\"/api/cart\", { productId });",
      "  }",
      "}",
      "",
      "@Component({",
      "  selector: \"app-product\",",
      "  standalone: true,",
      "  template: `",
      "    <button (click)=\"add(1)\">Add to cart</button>",
      "  `",
      "})",
      "export class ProductComponent {",
      "  constructor(private commands: CartCommands) {}",
      "",
      "  add(id: number) {",
      "    this.commands.addToCart(id).subscribe();",
      "  }",
      "}"
    ]
  },
  {
    "id": "mediator-coordinator",
    "name": "Mediator Pattern with Coordinator Service",
    "category": "Interaction & Composition",
    "shortDescription": "Coordinate interaction between sibling components.",
    "description": "A mediator service coordinates events between multiple independent components (e.g., filters and charts in a dashboard).",
    "exampleTs": [
      "import { Injectable } from \"@angular/core\";",
      "import { Subject } from \"rxjs\";",
      "import { Component } from \"@angular/core\";",
      "",
      "@Injectable({ providedIn: \"root\" })",
      "export class DashboardMediator {",
      "  private refreshSubject = new Subject<void>();",
      "  refresh$ = this.refreshSubject.asObservable();",
      "",
      "  requestRefresh() {",
      "    this.refreshSubject.next();",
      "  }",
      "}",
      "",
      "@Component({",
      "  selector: \"app-filter\",",
      "  standalone: true,",
      "  template: `",
      "    <button (click)=\"applyFilter()\">Apply filter</button>",
      "  `",
      "})",
      "export class FilterComponent {",
      "  constructor(private mediator: DashboardMediator) {}",
      "",
      "  applyFilter() {",
      "    this.mediator.requestRefresh();",
      "  }",
      "}",
      "",
      "@Component({",
      "  selector: \"app-chart\",",
      "  standalone: true,",
      "  template: `",
      "    <p>Chart data...</p>",
      "  `",
      "})",
      "export class ChartComponent {",
      "  constructor(private mediator: DashboardMediator) {",
      "    this.mediator.refresh$.subscribe(() => this.loadData());",
      "  }",
      "",
      "  loadData() {",
      "    console.log(\"Reload chart data\");",
      "  }",
      "}"
    ]
  },
  {
    "id": "strategy-injection-token",
    "name": "Strategy Pattern via Injection Tokens",
    "category": "Interaction & Composition",
    "shortDescription": "Swap algorithms by providing different services.",
    "description": "Define a strategy interface and use DI tokens to inject different implementations (e.g., StripeStrategy vs PaypalStrategy).",
    "exampleTs": [
      "import { Injectable, InjectionToken, Inject, Component } from \"@angular/core\";",
      "",
      "export interface PaymentStrategy {",
      "  pay(amount: number): void;",
      "}",
      "",
      "@Injectable()",
      "export class PaypalStrategy implements PaymentStrategy {",
      "  pay(amount: number) {",
      "    console.log(\"PayPal payment\", amount);",
      "  }",
      "}",
      "",
      "@Injectable()",
      "export class StripeStrategy implements PaymentStrategy {",
      "  pay(amount: number) {",
      "    console.log(\"Stripe payment\", amount);",
      "  }",
      "}",
      "",
      "export const PAYMENT_STRATEGY = new InjectionToken<PaymentStrategy>(\"PAYMENT_STRATEGY\");",
      "",
      "@Component({",
      "  selector: \"app-checkout\",",
      "  standalone: true,",
      "  providers: [",
      "    { provide: PAYMENT_STRATEGY, useClass: PaypalStrategy }",
      "  ],",
      "  template: `",
      "    <button (click)=\"checkout()\">Checkout</button>",
      "  `",
      "})",
      "export class CheckoutComponent {",
      "  constructor(@Inject(PAYMENT_STRATEGY) private strategy: PaymentStrategy) {}",
      "",
      "  checkout() {",
      "    this.strategy.pay(100);",
      "  }",
      "}"
    ]
  },
  {
    "id": "template-method-base-class",
    "name": "Template Method Pattern via Base Classes",
    "category": "Interaction & Composition",
    "shortDescription": "Base component defines algorithm skeleton.",
    "description": "Abstract base components implement shared algorithm steps and rely on subclasses to override key hooks.",
    "exampleTs": [
      "import { Component, OnInit } from \"@angular/core\";",
      "import { HttpClient } from \"@angular/common/http\";",
      "import { Observable } from \"rxjs\";",
      "import { NgFor } from \"@angular/common\";",
      "",
      "export abstract class ListBaseComponent<T> implements OnInit {",
      "  items: T[] = [];",
      "",
      "  abstract fetchItems(): Observable<T[]>;",
      "",
      "  ngOnInit() {",
      "    this.fetchItems().subscribe(items => (this.items = items));",
      "  }",
      "}",
      "",
      "interface UserBase {",
      "  id: number;",
      "  name: string;",
      "}",
      "",
      "@Component({",
      "  selector: \"app-user-list-base\",",
      "  standalone: true,",
      "  template: `",
      "    <ul>",
      "      <li @for=\"let u of items\">{{ u.name }}</li>",
      "    </ul>",
      "  `",
      "})",
      "export class UserListBaseComponent extends ListBaseComponent<UserBase> {",
      "  constructor(private http: HttpClient) {",
      "    super();",
      "  }",
      "",
      "  fetchItems(): Observable<UserBase[]> {",
      "    return this.http.get<UserBase[]>(\"/api/users\");",
      "  }",
      "}"
    ]
  },
  {
    "id": "chain-of-responsibility-interceptors",
    "name": "Chain of Responsibility (HTTP Interceptors)",
    "category": "Interaction & Composition",
    "shortDescription": "Chain HTTP request/response handlers.",
    "description": "Multiple HTTP interceptors each handle part of a request/response, forming a chain similar to Chain of Responsibility.",
    "exampleTs": [
      "import { Injectable } from \"@angular/core\";",
      "import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from \"@angular/common/http\";",
      "import { Observable } from \"rxjs\";",
      "",
      "@Injectable()",
      "export class AuthInterceptor implements HttpInterceptor {",
      "  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {",
      "    const cloned = req.clone({",
      "      setHeaders: { Authorization: \"Bearer token\" }",
      "    });",
      "    return next.handle(cloned);",
      "  }",
      "}",
      "",
      "@Injectable()",
      "export class LoggingInterceptor implements HttpInterceptor {",
      "  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {",
      "    console.log(\"Request\", req.url);",
      "    return next.handle(req);",
      "  }",
      "}"
    ]
  },
  {
    "id": "adapter-service",
    "name": "Adapter Pattern via Services",
    "category": "Interaction & Composition",
    "shortDescription": "Normalize awkward backend APIs.",
    "description": "Adapter services translate backend API shapes into clean frontend models so components remain unaffected by backend quirks.",
    "exampleTs": [
      "import { Injectable } from \"@angular/core\";",
      "import { HttpClient } from \"@angular/common/http\";",
      "import { map, Observable } from \"rxjs\";",
      "",
      "interface ApiUser {",
      "  first_name: string;",
      "  last_name: string;",
      "}",
      "",
      "export interface User {",
      "  fullName: string;",
      "}",
      "",
      "@Injectable({ providedIn: \"root\" })",
      "export class UserAdapterService {",
      "  constructor(private http: HttpClient) {}",
      "",
      "  getUsers(): Observable<User[]> {",
      "    return this.http.get<ApiUser[]>(\"/api/users\").pipe(",
      "      map(apiUsers =>",
      "        apiUsers.map(u => ({ fullName: `${u.first_name} ${u.last_name}` }))",
      "      )",
      "    );",
      "  }",
      "}"
    ]
  },
  {
    "id": "onpush-change-detection",
    "name": "OnPush Change Detection",
    "category": "Rendering & Performance",
    "shortDescription": "Render only when inputs or observables change.",
    "description": "ChangeDetectionStrategy.OnPush tells Angular to skip checks unless @Input() references change or an observable emits.",
    "exampleTs": [
      "import { Component, ChangeDetectionStrategy, Input } from \"@angular/core\";",
      "",
      "@Component({",
      "  selector: \"app-user-card\",",
      "  standalone: true,",
      "  changeDetection: ChangeDetectionStrategy.OnPush,",
      "  template: `",
      "    {{ user.name }}",
      "  `",
      "})",
      "export class UserCardComponent {",
      "  @Input() user!: { name: string };",
      "}"
    ]
  },
  {
    "id": "trackby-ngfor",
    "name": "trackBy for *ngFor – DEPRECATED",
    "category": "Rendering & Performance",
    "shortDescription": "DEPRECATED: use @for with track expressions instead of *ngFor + trackBy.",
    "description": "DEPRECATED in modern Angular: trackBy with *ngFor was the classic way to minimize DOM churn, but Angular 21 encourages @for with an inline track expression for better performance and readability.",
    "exampleTs": [
      "import { Component } from \"@angular/core\";",
      "import { NgFor } from \"@angular/common\";",
      "",
      "interface Item {",
      "  id: number;",
      "  name: string;",
      "}",
      "",
      "@Component({",
      "  selector: \"app-items\",",
      "  standalone: true,",
      "  imports: [NgFor],",
      "  template: `",
      "    <li *ngFor=\\\"let item of items; trackBy: trackById\\\">",
      "  "
    ],
    "exampleHtml": null
  },
  {
    "id": "control-flow-for",
    "name": "Built-in Control Flow: @for",
    "category": "Rendering & Performance",
    "shortDescription": "Use @for with track expressions instead of *ngFor / trackBy.",
    "description": "Angular's built-in @for block replaces *ngFor and accepts an inline track expression, offering a faster diffing algorithm and cleaner syntax.",
    "exampleTs": [
      "import { Component } from \"@angular/core\";",
      "",
      "interface Item {",
      "  id: number;",
      "  name: string;",
      "}",
      "",
      "@Component({",
      "  selector: \"app-items-for\",",
      "  standalone: true,",
      "  template: `",
      "    @for (item of items; track item.id) {",
      "      <div>{{ item.name }}</div>",
      "    }",
      "  `",
      "})",
      "export class ItemsForComponent {",
      "  items: Item[] = [",
      "    { id: 1, name: \"One\" },",
      "    { id: 2, name: \"Two\" }",
      "  ];",
      "}"
    ]
  },
  {
    "id": "virtual-scroll-cdk",
    "name": "Virtual Scrolling (CDK)",
    "category": "Rendering & Performance",
    "shortDescription": "Render only the visible slice of long lists.",
    "description": "Angular CDK virtual scroll shows just the visible portion of a long list to reduce DOM size.",
    "exampleTs": [
      "import { Component } from \"@angular/core\";",
      "import { ScrollingModule } from \"@angular/cdk/scrolling\";",
      "",
      "@Component({",
      "  selector: \"app-virtual-list\",",
      "  standalone: true,",
      "  imports: [ScrollingModule],",
      "  template: `",
      "    <cdk-virtual-scroll-viewport itemSize=\\\"50\\\" style=\\\"height: 300px\\\">",
      "      <div *cdkVirtualFor=\\\"let item of items\\\">",
      "        {{ item }}",
      "      </div>",
      "    </cdk-virtual-scroll-viewport>",
      "  `",
      "})",
      "export class VirtualListComponent {",
      "  items = Array.from({ length: 1000 }).map((_, i) => `Item ${i}`);",
      "}"
    ]
  },
  {
    "id": "lazy-loading-routes",
    "name": "Lazy Loading Routes",
    "category": "Rendering & Performance",
    "shortDescription": "Load feature code only when needed.",
    "description": "Lazy route configuration with loadChildren or loadComponent delays loading of feature bundles until the route is visited.",
    "exampleTs": [
      "import { Routes } from \"@angular/router\";",
      "",
      "export const routes: Routes = [",
      "  { path: 'feature', loadChildren: () => import('./feature/feature.module').then(m => m.FeatureModule) }",
      "];"
    ]
  },
  {
    "id": "debounce-throttle-rxjs",
    "name": "Debounce / Throttle with RxJS",
    "category": "Rendering & Performance",
    "shortDescription": "Limit how often expensive logic runs.",
    "description": "Use debounceTime, throttleTime, and distinctUntilChanged to avoid flooding the UI with updates from rapid events (typing, scrolling).",
    "exampleTs": [
      "import { Component } from \"@angular/core\";",
      "import { Subject } from \"rxjs\";",
      "import { debounceTime, distinctUntilChanged } from \"rxjs/operators\";",
      "",
      "@Component({",
      "  selector: \"app-search\",",
      "  standalone: true,",
      "  template: `",
      "    <input (input)=\\\"search$.next($event.target.value)\\\" placeholder=\\\"Search\\\" />",
      "  `",
      "})",
      "export class SearchComponent {",
      "  search$ = new Subject<string>();",
      "",
      "  constructor() {",
      "    this.search$",
      "      .pipe(",
      "        debounceTime(300),",
      "        distinctUntilChanged()",
      "      )",
      "      .subscribe(value => console.log(\\\"Search for\\\", value));",
      "  }",
      "}"
    ]
  },
  {
    "id": "facade",
    "name": "Facade Pattern",
    "category": "API & Data Integration",
    "shortDescription": "One simple API for complex underlying layers.",
    "description": "A facade service wraps NgRx, repositories, and HTTP calls behind a simple, UI-friendly interface.",
    "exampleTs": [
      "import { Injectable } from \"@angular/core\";",
      "import { Store } from \"@ngrx/store\";",
      "import { Observable } from \"rxjs\";",
      "",
      "import { Product } from \"./product.model\";",
      "import { loadProducts, addProduct } from \"./product.actions\";",
      "import { selectProducts, selectProductsLoading } from \"./product.selectors\";",
      "",
      "@Injectable({ providedIn: \"root\" })",
      "export class ProductsFacade {",
      "  products$: Observable<Product[]> = this.store.select(selectProducts);",
      "  loading$: Observable<boolean> = this.store.select(selectProductsLoading);",
      "",
      "  constructor(private store: Store) {}",
      "",
      "  loadProducts() {",
      "    this.store.dispatch(loadProducts());",
      "  }",
      "",
      "  addProduct(product: Product) {",
      "    this.store.dispatch(addProduct({ product }));",
      "  }",
      "}"
    ]
  },
  {
    "id": "repository",
    "name": "Repository Pattern",
    "category": "API & Data Integration",
    "shortDescription": "Abstract persistence and HTTP access.",
    "description": "Repository services encapsulate fetching, caching, and mapping data so the rest of the app deals with domain models only.",
    "exampleTs": [
      "import { Injectable } from \"@angular/core\";",
      "import { HttpClient } from \"@angular/common/http\";",
      "import { Observable } from \"rxjs\";",
      "",
      "export interface ProductRepoModel {",
      "  id: string;",
      "  name: string;",
      "}",
      "",
      "@Injectable({ providedIn: \"root\" })",
      "export class ProductRepository {",
      "  constructor(private http: HttpClient) {}",
      "",
      "  getProducts(): Observable<ProductRepoModel[]> {",
      "    return this.http.get<ProductRepoModel[]>(\"/api/products\");",
      "  }",
      "}"
    ]
  },
  {
    "id": "ngrx-effects",
    "name": "Effects Pattern (NgRx Effects)",
    "category": "API & Data Integration",
    "shortDescription": "Side-effectful async operations for the store.",
    "description": "NgRx Effects run async logic (HTTP calls, logging, routing) in response to actions, separate from reducers and components.",
    "exampleTs": [
      "import { Injectable } from \"@angular/core\";",
      "import { Actions, createEffect, ofType } from \"@ngrx/effects\";",
      "import { HttpClient } from \"@angular/common/http\";",
      "import { catchError, map, of, switchMap } from \"rxjs\";",
      "",
      "import {",
      "  loadProducts,",
      "  loadProductsSuccess,",
      "  loadProductsFailure",
      "} from \"./product.actions\";",
      "import { Product } from \"./product.model\";",
      "",
      "@Injectable()",
      "export class ProductsEffects {",
      "  loadProducts$ = createEffect(() =>",
      "    this.actions$.pipe(",
      "      ofType(loadProducts),",
      "      switchMap(() =>",
      "        this.http.get<Product[]>(\"/api/products\").pipe(",
      "          map(products => loadProductsSuccess({ products })),",
      "          catchError(() => of(loadProductsFailure()))",
      "        )",
      "      )",
      "    )",
      "  );",
      "",
      "  constructor(private actions$: Actions, private http: HttpClient) {}",
      "}"
    ]
  },
  {
    "id": "dependency-injection",
    "name": "Dependency Injection (DI)",
    "category": "Core / Architectural",
    "shortDescription": "Supply dependencies from the outside using Angular DI.",
    "description": "Dependency Injection in Angular uses injectors and providers so components and services receive ready-to-use dependencies instead of constructing them manually.",
    "exampleTs": [
      "import { Injectable } from \"@angular/core\";",
      "import { Component } from \"@angular/core\";",
      "",
      "@Injectable({ providedIn: \"root\" })",
      "export class LoggerService {",
      "  log(msg: string) {",
      "    console.log(\\\"[LOG]\\\", msg);",
      "  }",
      "}",
      "",
      "@Component({",
      "  selector: \"app-home\",",
      "  standalone: true,",
      "  template: `",
      "    <button (click)=\\\"sayHi()\\\">Say hi</button>",
      "  `",
      "})",
      "export class HomeComponent {",
      "  constructor(private logger: LoggerService) {}",
      "",
      "  sayHi() {",
      "    this.logger.log(\\\"Hello from HomeComponent\\\");",
      "  }",
      "}"
    ]
  },
  {
    "id": "pipe-pattern",
    "name": "Pipe Pattern",
    "category": "Rendering & Performance",
    "shortDescription": "Transform data in templates using pipes.",
    "description": "Use Angular pipes to format and transform data directly in templates, keeping components clean.",
    "exampleTs": [
      "import { Component } from '@angular/core';",
      "",
      "@Component({",
      "  selector: 'app-date-pipe',",
      "  standalone: true,",
      "  template: `",
      "    <p>{{ today | date }}</p>",
      "  `",
      "})",
      "export class DatePipeComponent {",
      "  today = new Date();",
      "}"
    ]
  },
  {
    "id": "rxjs-observable-pattern",
    "name": "RxJS Observable Pattern",
    "category": "State & Data",
    "shortDescription": "Use RxJS observables for reactive data streams.",
    "description": "Leverage RxJS observables to handle asynchronous data streams in Angular applications.",
    "exampleTs": [
      "import { Component } from '@angular/core';",
      "import { interval } from 'rxjs';",
      "",
      "@Component({",
      "  selector: 'app-timer',",
      "  standalone: true,",
      "  template: `",
      "    <p>Seconds: {{ seconds }}</p>",
      "  `",
      "})",
      "export class TimerComponent {",
      "  seconds = 0;",
      "",
      "  constructor() {",
      "    interval(1000).subscribe(val => this.seconds = val);",
      "  }",
      "}"
    ]
  },
  {
    "id": "async-pipe-pattern",
    "name": "Async Pipe Pattern",
    "category": "Rendering & Performance",
    "shortDescription": "Use the async pipe to handle observables in templates.",
    "description": "The async pipe automatically subscribes to observables and unsubscribes when the component is destroyed.",
    "exampleTs": [
      "import { Component } from '@angular/core';",
      "import { of } from 'rxjs';",
      "",
      "@Component({",
      "  selector: 'app-async-pipe',",
      "  standalone: true,",
      "  template: `",
      "    <p>{{ data$ | async }}</p>",
      "  `",
      "})",
      "export class AsyncPipeComponent {",
      "  data$ = of('Hello, Async Pipe!');",
      "}"
    ]
  },
  {
    "id": "class-decorators",
    "name": "Decorator Pattern via Class Decorators",
    "category": "Interaction & Composition",
    "shortDescription": "Decorators add metadata/behavior to classes.",
    "description": "Angular decorators like @Component and @Injectable are special cases; custom decorators can also wrap or log component behavior.",
    "exampleTs": [
      "import { Component } from '@angular/core';",
      "",
      "function LogClass(constructor: Function) {",
      "  console.log('Component created:', constructor.name);",
      "}",
      "",
      "@LogClass",
      "@Component({",
      "  selector: 'app-logged',",
      "  standalone: true,",
      "  template: `I am logged`",
      "})",
      "export class LoggedComponent {}"
    ]
  }
]
