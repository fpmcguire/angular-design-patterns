[
  {
    "id": "information-expert",
    "name": "Information Expert",
    "category": "Assignment",
    "shortDescription": "Assign responsibilities to the class that has the necessary information.",
    "description": "In Angular, services that own data (like repositories or stores) are natural “Information Experts” for operations that compute or transform that data.",
    "exampleTs": [
      "import { Injectable } from '@angular/core';",
      "",
      "export interface OrderLine {",
      "  quantity: number;",
      "  unitPrice: number;",
      "}",
      "",
      "@Injectable({ providedIn: 'root' })",
      "export class OrderCalculator {",
      "  // Information Expert: this service has the data and the behavior",
      "  total(lines: OrderLine[]): number {",
      "    return lines.reduce((sum, l) => sum + l.quantity * l.unitPrice, 0);",
      "  }",
      "}"
    ]
  },
  {
    "id": "creator",
    "name": "Creator",
    "category": "Assignment",
    "shortDescription": "Assign the responsibility of creating an object to a class that aggregates or closely uses it.",
    "description": "Components or services that aggregate other entities are good candidates to create them, instead of constructing them in random places.",
    "exampleTs": [
      "import { Injectable } from '@angular/core';",
      "",
      "export interface Todo {",
      "  id: number;",
      "  text: string;",
      "  done: boolean;",
      "}",
      "",
      "@Injectable({ providedIn: 'root' })",
      "export class TodoListService {",
      "  private nextId = 1;",
      "  private todos: Todo[] = [];",
      "",
      "  // Creator: this service aggregates Todo, so it creates them",
      "  create(text: string): Todo {",
      "    const todo: Todo = { id: this.nextId++, text, done: false };",
      "    this.todos.push(todo);",
      "    return todo;",
      "  }",
      "}"
    ]
  },
  {
    "id": "controller",
    "name": "Controller",
    "category": "Assignment",
    "shortDescription": "Represent the overall system or use case and coordinate work.",
    "description": "An Angular component, façade, or dedicated “UseCase” service can act as a GRASP Controller that coordinates calls to domain objects and services.",
    "exampleTs": [
      "import { Injectable } from '@angular/core';",
      "import { TodoListService } from './todo-list.service';",
      "",
      "@Injectable({ providedIn: 'root' })",
      "export class TodoController {",
      "  constructor(private list: TodoListService) {}",
      "",
      "  addTodoFromInput(text: string) {",
      "    if (!text.trim()) return;",
      "    this.list.create(text.trim());",
      "  }",
      "}"
    ]
  },
  {
    "id": "low-coupling",
    "name": "Low Coupling",
    "category": "Coupling & Cohesion",
    "shortDescription": "Minimize how much one element depends on others.",
    "description": "Angular encourages low coupling via DI: components depend on abstractions (interfaces/services) instead of concrete implementations or global state.",
    "exampleTs": [
      "import { Injectable } from '@angular/core';",
      "",
      "export interface Clock {",
      "  now(): Date;",
      "}",
      "",
      "@Injectable({ providedIn: 'root' })",
      "export class SystemClock implements Clock {",
      "  now() {",
      "    return new Date();",
      "  }",
      "}",
      "",
      "@Injectable({ providedIn: 'root' })",
      "export class AuditService {",
      "  constructor(private clock: Clock) {} // low coupling: depends on interface",
      "",
      "  audit(action: string) {",
      "    console.log(this.clock.now().toISOString(), action);",
      "  }",
      "}"
    ]
  },
  {
    "id": "high-cohesion",
    "name": "High Cohesion",
    "category": "Coupling & Cohesion",
    "shortDescription": "Keep related responsibilities together and unrelated ones apart.",
    "description": "A cohesive Angular service or component has a narrow, focused purpose (e.g., “auth”, “cart”, “order-summary”) instead of mixing unrelated concerns.",
    "exampleTs": [
      "import { Injectable } from '@angular/core';",
      "",
      "// High cohesion: everything here is about authentication.",
      "// No logging, routing, or UI rendering mixed in.",
      "@Injectable({ providedIn: 'root' })",
      "export class AuthService {",
      "  private token: string | null = null;",
      "",
      "  login(username: string, password: string) {",
      "    // imagine HTTP call here",
      "    this.token = 'fake-token';",
      "  }",
      "",
      "  logout() {",
      "    this.token = null;",
      "  }",
      "",
      "  isLoggedIn(): boolean {",
      "    return !!this.token;",
      "  }",
      "}"
    ]
  },
  {
    "id": "polymorphism",
    "name": "Polymorphism",
    "category": "Coupling & Cohesion",
    "shortDescription": "Use polymorphism to handle alternatives based on type.",
    "description": "With Angular DI and TypeScript interfaces, you can vary behavior (e.g., payment or logging) by injecting different implementations.",
    "exampleTs": [
      "import { Injectable } from '@angular/core';",
      "",
      "export interface ShippingStrategy {",
      "  calculateCost(weightKg: number): number;",
      "}",
      "",
      "@Injectable()",
      "export class StandardShipping implements ShippingStrategy {",
      "  calculateCost(weightKg: number): number {",
      "    return 5 + weightKg * 0.5;",
      "  }",
      "}",
      "",
      "@Injectable()",
      "export class ExpressShipping implements ShippingStrategy {",
      "  calculateCost(weightKg: number): number {",
      "    return 10 + weightKg * 1.0;",
      "  }",
      "}"
    ]
  },
  {
    "id": "pure-fabrication",
    "name": "Pure Fabrication",
    "category": "Coupling & Cohesion",
    "shortDescription": "Introduce a class that does not represent a domain concept to achieve better cohesion or reuse.",
    "description": "Repositories, facades, and mappers in Angular are classic examples of Pure Fabrication: invented classes that improve reuse and structure.",
    "exampleTs": [
      "import { Injectable } from '@angular/core';",
      "import { HttpClient } from '@angular/common/http';",
      "",
      "export interface User {",
      "  id: string;",
      "  name: string;",
      "}",
      "",
      "// Pure Fabrication: UserRepository is not a domain entity,",
      "// but a helper that centralizes persistence logic.",
      "@Injectable({ providedIn: 'root' })",
      "export class UserRepository {",
      "  constructor(private http: HttpClient) {}",
      "",
      "  findAll() {",
      "    return this.http.get<User[]>('/api/users');",
      "  }",
      "}"
    ]
  },
  {
    "id": "indirection",
    "name": "Indirection",
    "category": "Protection & Indirection",
    "shortDescription": "Reduce direct coupling between elements by introducing an intermediate.",
    "description": "Mediator or facade services in Angular are forms of indirection: components talk to a single intermediary instead of being coupled to each other or to many services.",
    "exampleTs": [
      "import { Injectable } from '@angular/core';",
      "import { Subject } from 'rxjs';",
      "",
      "// Indirection: ChatBus sits between senders and receivers.",
      "@Injectable({ providedIn: 'root' })",
      "export class ChatBus {",
      "  private messageSubject = new Subject<string>();",
      "  messages$ = this.messageSubject.asObservable();",
      "",
      "  send(message: string) {",
      "    this.messageSubject.next(message);",
      "  }",
      "}"
    ]
  },
  {
    "id": "protected-variations",
    "name": "Protected Variations",
    "category": "Protection & Indirection",
    "shortDescription": "Protect elements from the variations of other elements by creating stable interfaces.",
    "description": "In Angular, you can protect components from API changes by exposing stable services and interfaces, adapting external changes behind those boundaries.",
    "exampleTs": [
      "import { Injectable } from '@angular/core';",
      "",
      "// Stable boundary: ConfigService always exposes getApiUrl,",
      "// even if the underlying configuration source changes.",
      "@Injectable({ providedIn: 'root' })",
      "export class ConfigService {",
      "  getApiUrl(): string {",
      "    // could read from environment, remote config, etc.",
      "    return 'https://api.example.com';",
      "  }",
      "}"
    ]
  }
]
